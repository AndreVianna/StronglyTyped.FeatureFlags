namespace StronglyTyped.FeatureFlags.Generator;

[Generator]
public class FeatureFlagsGenerator : IIncrementalGenerator {

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        //#if DEBUG
        //        if (!Debugger.IsAttached) {
        //            Debugger.Launch();
        //        }
        //#endif
        var flagHolders = context.SyntaxProvider
            .CreateSyntaxProvider(IsFeatureFlagsHolder, GetFeatureFlagsHolderTypeOrDefault)
            .Where(type => type is not null)
            .Collect();

        context.RegisterSourceOutput(flagHolders, GenerateCode!);
    }

    //public class FeatureFlagsGenerator : IIncrementalGenerator {
    //    public void Initialize(IncrementalGeneratorInitializationContext context) {
    //#if DEBUG
    //        if (!Debugger.IsAttached) {
    //            Debugger.Launch();
    //        }
    //#endif
    //        var flagHolders = context.SyntaxProvider
    //            .CreateSyntaxProvider(IsFeatureFlagsHolder, GetFeatureFlagsHolderTypeOrDefault)
    //            .Where(type => type is not null)
    //            .Collect();

    //        context.RegisterSourceOutput(flagHolders, GenerateCode!);
    //    }

    private static bool IsFeatureFlagsHolder(SyntaxNode syntaxNode, CancellationToken cancellationToken) {
        if (syntaxNode is not AttributeSyntax attribute) return false;
        var name = ExtractName(attribute.Name);
        return name is "FeatureFlagsHolder" or "FeatureFlagsHolderAttribute";
    }

    private static string? ExtractName(NameSyntax? name) {
        while (name != null) {
            switch (name) {
                case IdentifierNameSyntax ins: return ins.Identifier.Text;
                case QualifiedNameSyntax qns: name = qns.Right; break;
                default: return null;
            }
        }

        return null;
    }

    private static ITypeSymbol? GetFeatureFlagsHolderTypeOrDefault(GeneratorSyntaxContext context, CancellationToken cancellationToken) {
        var attributeSyntax = (AttributeSyntax)context.Node;
        if (attributeSyntax.Parent?.Parent is not ClassDeclarationSyntax classDeclaration)
            return null;

        var type = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as ITypeSymbol;

        return type is null || !IsFlagHolder(type) ? null : type;
    }

    private static bool IsFlagHolder(ISymbol type) {
        var attributes = type.GetAttributes();
        foreach (var attributeData in attributes) {
            if (attributeData.AttributeClass?.ToString() == "StronglyTyped.FeatureFlags.FeatureFlagsHolderAttribute") return true;
        }
        return false;
    }

    private static void GenerateCode(SourceProductionContext context, ImmutableArray<ITypeSymbol> flagHolders) {
        if (flagHolders.IsDefaultOrEmpty)
            return;

        var distinctTypes = flagHolders.Distinct(SymbolEqualityComparer.Default).Cast<ITypeSymbol>().ToArray();
        foreach (var type in distinctTypes) {
            var typeNamespace = type!.ContainingNamespace.IsGlobalNamespace
                ? null
                : type.ContainingNamespace.ToString();
            var code = GenerateCode(typeNamespace, type);
            var separator = typeNamespace is null ? null : ".";
            context.AddSource($"{typeNamespace}{separator}{type.Name}.g.cs", code);
        }
    }

    private static string GenerateCode(string? typeNamespace, ITypeSymbol type) {
        var typeName = type.Name;
        var items = GetItemNames(type);

        return
@$"// <auto-generated />

using System.Collections.Generic;

{(typeNamespace is null ? null : $@"namespace {typeNamespace}
{{")}
   partial class {typeName}
   {{
   // Items => {string.Join(",", items)} 
   }}
{(typeNamespace is null ? null : @"}
")}";
    }

    private static IEnumerable<string?> GetItemNames(ITypeSymbol type) {
        return type.GetMembers()
            .Select(m => {
                if (!m.IsStatic ||
                    m.DeclaredAccessibility != Accessibility.Public ||
                    m is not IFieldSymbol field)
                    return null;

                return SymbolEqualityComparer.Default.Equals(field.Type, type)
                    ? field.Name
                    : null;
            })
            .Where(field => field is not null);
    }
}
