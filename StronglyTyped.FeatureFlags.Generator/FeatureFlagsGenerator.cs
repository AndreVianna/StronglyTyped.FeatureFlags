using System.Diagnostics;

namespace StronglyTyped.FeatureFlags.Generator;

[Generator]
public class FeatureFlagsGenerator : IIncrementalGenerator {

    public void Initialize(IncrementalGeneratorInitializationContext context) {
#if DEBUG
        if (!Debugger.IsAttached) {
            Debugger.Launch();
        }
#endif
        var flagHolders = context.SyntaxProvider
            .CreateSyntaxProvider(IsFeatureFlagsHolderAttribute, GetFeatureFlagsHolderTypeOrDefault)
            .Where(type => type is not null)
            .Collect();

        context.RegisterSourceOutput(flagHolders, GenerateFiles!);
    }

    private static bool IsFeatureFlagsHolderAttribute(SyntaxNode syntaxNode, CancellationToken cancellationToken) {
        if (syntaxNode is not AttributeSyntax attribute) return false;
        var name = ExtractName(attribute.Name);
        return name is "FeatureFlagsHolder" or "FeatureFlagsHolderAttribute";
    }

    private static string? ExtractName(NameSyntax? name) {
        while (name != null) {
            switch (name) {
                case IdentifierNameSyntax ins: return ins.Identifier.Text;
                case QualifiedNameSyntax qns: name = qns.Right; break;
                default: return null;
            }
        }

        return null;
    }

    private static ITypeSymbol? GetFeatureFlagsHolderTypeOrDefault(GeneratorSyntaxContext context, CancellationToken cancellationToken) {
        var attributeSyntax = (AttributeSyntax)context.Node;
        return attributeSyntax.Parent?.Parent is ClassDeclarationSyntax classDeclaration &&
            context.SemanticModel.GetDeclaredSymbol(classDeclaration) is ITypeSymbol type &&
            HasFlagsHolderAttribute(type)
                ? type
                : null;
    }

    private static bool HasFlagsHolderAttribute(ISymbol type) {
        var attributes = type.GetAttributes();
        foreach (var attributeData in attributes) {
            if (attributeData.AttributeClass?.ToString() == "StronglyTyped.FeatureFlags.FeatureFlagsHolderAttribute") return true;
        }
        return false;
    }

    private static void GenerateFiles(SourceProductionContext context, ImmutableArray<ITypeSymbol> flagsHolders) {
        if (flagsHolders.IsDefaultOrEmpty)
            return;

        var distinctFlagsHolders = flagsHolders.Distinct(SymbolEqualityComparer.Default).Cast<ITypeSymbol>().ToArray();
        foreach (var flagsHolder in distinctFlagsHolders) {
            GenerateFile(context, flagsHolder);
        }
    }

    private static void GenerateFile(SourceProductionContext context, ITypeSymbol flagsHolder) {
        var typeNamespace = flagsHolder!.ContainingNamespace.IsGlobalNamespace
            ? null
            : flagsHolder.ContainingNamespace.ToString();
        var code = GenerateCode(context, typeNamespace, flagsHolder);
        context.AddSource($"{flagsHolder.Name}.g.cs", code);
    }

    private static string GenerateCode(SourceProductionContext context, string? typeNamespace, ITypeSymbol flagsHolder) {
        Compilation.GetSemanticModel();
        var typeName = flagsHolder.Name;
        var items = GetItemNames(context, flagsHolder);

        return
@$"// <auto-generated />

using System.Collections.Generic;

{(typeNamespace is null ? null : $@"namespace {typeNamespace}
{{")}
   partial class {typeName}
   {{
   // Items => {string.Join(",", items)} 
   }}
{(typeNamespace is null ? null : @"}
")}";
    }

    private static IEnumerable<string?> GetItemNames(SourceProductionContext context, ITypeSymbol flagsHolder) {
        return flagsHolder.GetMembers()
            .Where(m => m.IsStatic &&
                    m.DeclaredAccessibility != Accessibility.Public &&
                    m is IFieldSymbol field &&
                    IsArrayOfFeatureAndProvider(field.Type))
            .Cast<IFieldSymbol>()
            .Select(f => TransformField(context, f));
    }

    private static bool IsArrayOfFeatureAndProvider(ITypeSymbol typeSymbol)
        => typeSymbol.ToString() == "(string Feature, string Provider)[]";

    private static string TransformField(SourceProductionContext context, IFieldSymbol fieldSymbol) {
        return fieldSymbol.Name;
    }
}
