namespace StronglyTyped.FeatureFlags.SourceGeneration.Tests;
using static Helpers.GeneratorRunner;

[ExcludeFromCodeCoverage]
public class SourceGenerationTests {

    #region content strings
    private const string _emptyInterface = @"// <auto-generated/>
#nullable enable

using StronglyTyped.FeatureFlags;

namespace SourceGeneration.Tests;

public interface ITestFeatures
{
}
";

    private const string _emptyClass = @"// <auto-generated/>
#nullable enable

using StronglyTyped.FeatureFlags;

namespace SourceGeneration.Tests;

partial class TestFeatures : ITestFeatures
{
    private readonly IFeatureAccessor _featureAccessor;

    public TestFeatures(IFeatureAccessor featureAccessor)
    {
        _featureAccessor = featureAccessor;
    }
}
";

    private const string _interfaceWithTwoProperties = @"// <auto-generated/>
#nullable enable

using StronglyTyped.FeatureFlags;

namespace SourceGeneration.Tests;

public interface ITestFeatures
{
    IFeatureState Feature1 { get; }
    IFeatureState Feature2 { get; }
}
";

    private const string _classWithTwoProperties = @"// <auto-generated/>
#nullable enable

using StronglyTyped.FeatureFlags;

namespace SourceGeneration.Tests;

partial class TestFeatures : ITestFeatures
{
    private readonly IFeatureAccessor _featureAccessor;

    public TestFeatures(IFeatureAccessor featureAccessor)
    {
        _featureAccessor = featureAccessor;
    }
    public IFeatureState Feature1 => _featureAccessor.For(nameof(Feature1));
    public IFeatureState Feature2 => _featureAccessor.For(nameof(Feature2));
}
";


    private const string _interfaceWithSubSection = @"// <auto-generated/>
#nullable enable

using StronglyTyped.FeatureFlags;

namespace SourceGeneration.Tests;

public interface ITestFeatures
{
    IFeatureState Feature1 { get; }
    IFeatureState Feature2 { get; }
    ISubSection SubSection { get; }
}
";

    private const string _classWithSubSection = @"// <auto-generated/>
#nullable enable

using StronglyTyped.FeatureFlags;

namespace SourceGeneration.Tests;

partial class TestFeatures : ITestFeatures
{
    private readonly IFeatureAccessor _featureAccessor;

    public TestFeatures(IFeatureAccessor featureAccessor)
    {
        _featureAccessor = featureAccessor;
        SubSection = new SubSection(_featureAccessor);
    }
    public IFeatureState Feature1 => _featureAccessor.For(nameof(Feature1));
    public IFeatureState Feature2 => _featureAccessor.For(nameof(Feature2));
    public ISubSection SubSection { get; }
}
";
    #endregion

    [Theory]
    [InlineData("string")]
    [InlineData("String")]
    [InlineData("System.String")]
    public async Task SourceFile_WithAClass_WithFeatureListAttribute_AndAPrivateStringArrayField_InitializedWithTwoFeatures_GeneratesCode_WithTwoProperties(string arrayType) {
        var code = @$"
using StronglyTyped.FeatureFlags;

namespace SourceGeneration.Tests;

[FeatureList(nameof(_availableFeatures))]
public partial class TestFeatures {{
    private static readonly {arrayType}[] _availableFeatures = {{
        ""Feature1"",
        ""Feature2""
    }};
}}
";

        var (diagnostics, resultedCode) = await RunAsync(code);

        diagnostics.Length.Should().Be(0);
        resultedCode.Length.Should().Be(2);
        resultedCode[0].SourceText.ToString().Should().Be(_interfaceWithTwoProperties);
        resultedCode[1].SourceText.ToString().Should().Be(_classWithTwoProperties);
    }

    [Fact]
    public async Task SourceFile_WithOldNamespacesStyle_AndValidClass_GeneratesCode_WithTwoProperties() {
        const string code = @"
using StronglyTyped.FeatureFlags;

namespace SourceGeneration.Tests {
    [FeatureList(nameof(_availableFeatures))]
    public partial class TestFeatures {
        private static readonly string[] _availableFeatures = {
            ""Feature1"",
            ""Feature2""
        };
    }
}
";

        var (diagnostics, resultedCode) = await RunAsync(code);

        diagnostics.Length.Should().Be(0);
        resultedCode.Length.Should().Be(2);
        resultedCode[0].SourceText.ToString().Should().Be(_interfaceWithTwoProperties);
        resultedCode[1].SourceText.ToString().Should().Be(_classWithTwoProperties);
    }

    [Fact]
    public async Task SourceFile_WithAValidClass_WithNameOfItem_GeneratesCode_WithSubSection() {
        const string code = @"
using StronglyTyped.FeatureFlags;

namespace SourceGeneration.Tests;

[FeatureList(nameof(_availableFeatures))]
public partial class TestFeatures {
    private static readonly string[] _availableFeatures = {
        ""Feature1"",
        ""Feature2"",
        nameof(SubSection)
    };
}
";

        var (diagnostics, resultedCode) = await RunAsync(code);

        diagnostics.Length.Should().Be(0);
        resultedCode.Length.Should().Be(2);
        resultedCode[0].SourceText.ToString().Should().Be(_interfaceWithSubSection);
        resultedCode[1].SourceText.ToString().Should().Be(_classWithSubSection);
    }

    [Fact]
    public async Task SourceFile_WithoutNamespace_DoesNotGenerateCode() {
        const string code = @"
using StronglyTyped.FeatureFlags;

[FeatureList(nameof(_availableFeatures))]
public partial class TestFeatures {
    private static readonly string[] _availableFeatures = {
        ""Feature1"",
        ""Feature2""
    };
}
";

        var (diagnostics, resultedCode) = await RunAsync(code);

        diagnostics.Length.Should().Be(0);
        resultedCode.Length.Should().Be(0);
    }

    [Fact]
    public async Task SourceFile_WithAClassWithNoAttributes_DoesNotGenerateCode() {
        const string code = @"
using StronglyTyped.FeatureFlags;

namespace SourceGeneration.Tests;

public partial class TestFeatures {
    private static readonly string[] _availableFeatures = {
        ""Feature1"",
        ""Feature2""
    };
}
";

        var (diagnostics, resultedCode) = await RunAsync(code);

        diagnostics.Length.Should().Be(0);
        resultedCode.Length.Should().Be(0);
    }

    [Fact]
    public async Task SourceFile_WithAClass_WithoutFeatureListAttribute_DoesNotGenerateCode() {
        const string code = @"
using StronglyTyped.FeatureFlags;

namespace SourceGeneration.Tests;

[Obsolete]
public partial class TestFeatures {
    private static readonly string[] _availableFeatures = {
        ""Feature1"",
        ""Feature2""
    };
}
";

        var (diagnostics, resultedCode) = await RunAsync(code);

        diagnostics.Length.Should().Be(0);
        resultedCode.Length.Should().Be(0);
    }

    [Fact]
    public async Task SourceFile_WithAValidClass_WithAProperty_GeneratesCode_WithNoProperties() {
        const string code = @"
using StronglyTyped.FeatureFlags;

namespace SourceGeneration.Tests;

[FeatureList(""_availableFeatures"")]
public partial class TestFeatures {
    public static string[] AvailableFeatures { get; }
}
";

        var (diagnostics, resultedCode) = await RunAsync(code);

        diagnostics.Length.Should().Be(1);
        diagnostics[0].Descriptor.Description.ToString().Should().Contain("A field with name '_availableFeatures' was not found.");
        resultedCode.Length.Should().Be(0);
    }

    [Fact]
    public async Task SourceFile_WithAValidClass_WithAPublicField_GeneratesCode_WithNoProperties() {
        const string code = @"
using StronglyTyped.FeatureFlags;

namespace SourceGeneration.Tests;

[FeatureList(nameof(_availableFeatures))]
public partial class TestFeatures {
    public static readonly string[] _availableFeatures = {
        ""Feature1"",
        ""Feature2""
    };
}
";

        var (diagnostics, resultedCode) = await RunAsync(code);

        diagnostics.Length.Should().Be(1);
        diagnostics[0].Descriptor.Description.ToString().Should().Contain("The '_availableFeatures' must be private.");
        resultedCode.Length.Should().Be(0);
    }

    [Fact]
    public async Task SourceFile_WithAValidClass_WithNotArrayField_GeneratesCode_WithNoProperties() {
        const string code = @"
using StronglyTyped.FeatureFlags;

namespace SourceGeneration.Tests;

[FeatureList(nameof(_availableFeatures))]
public partial class TestFeatures {
    private static string _availableFeatures;
}
";

        var (diagnostics, resultedCode) = await RunAsync(code);

        diagnostics.Length.Should().Be(1);
        diagnostics[0].Descriptor.Description.ToString().Should().Contain("The '_availableFeatures' field must be a string array.");
        resultedCode.Length.Should().Be(0);
    }

    [Fact]
    public async Task SourceFile_WithAValidClass_WithNoInitializer_GeneratesCode_WithNoProperties() {
        const string code = @"
using StronglyTyped.FeatureFlags;

namespace SourceGeneration.Tests;

[FeatureList(nameof(_availableFeatures))]
public partial class TestFeatures {{
    private static readonly string[] _availableFeatures;
}}
";

        var (diagnostics, resultedCode) = await RunAsync(code);

        diagnostics.Length.Should().Be(0);
        resultedCode.Length.Should().Be(2);
        resultedCode[0].SourceText.ToString().Should().Be(_emptyInterface);
        resultedCode[1].SourceText.ToString().Should().Be(_emptyClass);
    }

    [Fact]
    public async Task SourceFile_WithAValidClass_WithAnArrayOfAnInvalidType_GeneratesCode_WithNoProperties() {
        const string code = @"
using StronglyTyped.FeatureFlags;

namespace SourceGeneration.Tests;

[FeatureList(nameof(_availableFeatures))]
public partial class TestFeatures {
    private static readonly int[] _availableFeatures = {
        1,
        2
    };
}
";

        var (diagnostics, resultedCode) = await RunAsync(code);

        diagnostics.Length.Should().Be(1);
        diagnostics[0].Descriptor.Description.ToString().Should().Contain("The '_availableFeatures' field must be a string array.");
        resultedCode.Length.Should().Be(0);
    }

    [Fact]
    public async Task SourceFile_WithAValidClass_WithAnEmptyStringArray_GeneratesCode_WithNoProperties() {
        const string code = @"
using StronglyTyped.FeatureFlags;

namespace SourceGeneration.Tests;

[FeatureList(nameof(_availableFeatures))]
public partial class TestFeatures {
    private static readonly String[] _availableFeatures = {
    };
}
";

        var (diagnostics, resultedCode) = await RunAsync(code);

        diagnostics.Length.Should().Be(0);
        resultedCode.Length.Should().Be(2);
        resultedCode[0].SourceText.ToString().Should().Be(_emptyInterface);
        resultedCode[1].SourceText.ToString().Should().Be(_emptyClass);
    }

    [Fact]
    public async Task SourceFile_WithAValidClass_WithNonLiteralValue_GeneratesCode_WithOnlyLiteralValues() {
        const string code = @"
using StronglyTyped.FeatureFlags;

namespace SourceGeneration.Tests;

[FeatureList(nameof(_availableFeatures))]
public partial class TestFeatures {
    private const string _feature3 = ""Feature3"";

    private static readonly String[] _availableFeatures = {
         ""Feature1"",
        ""Feature2""
       _feature3,
       $""Feature{4}"" 
    };
}
";

        var (diagnostics, resultedCode) = await RunAsync(code);

        diagnostics.Length.Should().Be(0);
        resultedCode.Length.Should().Be(2);
        resultedCode[0].SourceText.ToString().Should().Be(_interfaceWithTwoProperties);
        resultedCode[1].SourceText.ToString().Should().Be(_classWithTwoProperties);
    }
}
